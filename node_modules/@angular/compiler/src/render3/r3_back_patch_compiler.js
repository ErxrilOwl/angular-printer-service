/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@angular/compiler/src/render3/r3_back_patch_compiler", ["require", "exports", "tslib", "@angular/compiler/src/compiler", "@angular/compiler/src/output/output_ast", "@angular/compiler/src/template_parser/binding_parser", "@angular/compiler/src/render3/r3_pipe_compiler", "@angular/compiler/src/render3/r3_types", "@angular/compiler/src/render3/r3_view_compiler"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var compiler_1 = require("@angular/compiler/src/compiler");
    var o = require("@angular/compiler/src/output/output_ast");
    var binding_parser_1 = require("@angular/compiler/src/template_parser/binding_parser");
    var r3_pipe_compiler_1 = require("@angular/compiler/src/render3/r3_pipe_compiler");
    var r3_types_1 = require("@angular/compiler/src/render3/r3_types");
    var r3_view_compiler_1 = require("@angular/compiler/src/render3/r3_view_compiler");
    /**
     * Produce the back-patching function for the given module to the output context.
     */
    function compileModuleBackPatch(outputCtx, name, module, kind, backPatchReferenceOf, parseTemplate, reflector, resolver) {
        var imports = [];
        var statements = [];
        try {
            // Call dependent back patching
            for (var _a = tslib_1.__values(module.importedModules), _b = _a.next(); !_b.done; _b = _a.next()) {
                var importedModule = _b.value;
                var importBackPatchFunction = backPatchReferenceOf(importedModule.type);
                // e.g. // @BUILD_OPTIMIZER_REMOVE
                imports.push(new o.CommentStmt(r3_types_1.BUILD_OPTIMIZER_REMOVE));
                // e.g. ngBackPatch_some_other_module_Module();
                imports.push(importBackPatchFunction.callFn([]).toStmt());
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // The local output context allows collecting the back-patch statements that
        // are generated by the various compilers which allows putting placing them
        // into the body of a function instead of at global scope.
        var localCtx = {
            statements: statements,
            constantPool: outputCtx.constantPool,
            genFilePath: outputCtx.genFilePath,
            importExpr: outputCtx.importExpr
        };
        // e.g. export function ngBackPatch_some_module_Lib1Module()
        if (kind === 0 /* Renderer2 */) {
            // For all Renderer2 modules generate back-patching code for all the components, directives,
            // pipes, and injectables as well as the injector def for the module itself.
            var expressionParser = new compiler_1.Parser(new compiler_1.Lexer());
            var elementSchemaRegistry = new compiler_1.DomElementSchemaRegistry();
            var errors = [];
            var hostBindingParser = new binding_parser_1.BindingParser(expressionParser, compiler_1.DEFAULT_INTERPOLATION_CONFIG, elementSchemaRegistry, [], errors);
            try {
                // Back-patch all declared directive and components
                for (var _d = tslib_1.__values(module.declaredDirectives), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var declaredDirective = _e.value;
                    var declaredDirectiveMetadata = resolver.getDirectiveMetadata(declaredDirective.reference);
                    if (declaredDirectiveMetadata.isComponent) {
                        var _f = parseTemplate(declaredDirectiveMetadata, module, module.transitiveModule.directives), parsedTemplate = _f.template, parsedPipes = _f.pipes;
                        r3_view_compiler_1.compileComponent(localCtx, declaredDirectiveMetadata, parsedPipes, parsedTemplate, reflector, hostBindingParser, 1 /* BackPatch */);
                    }
                    else {
                        r3_view_compiler_1.compileDirective(localCtx, declaredDirectiveMetadata, reflector, hostBindingParser, 1 /* BackPatch */);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_g = _d.return)) _g.call(_d);
                }
                finally { if (e_2) throw e_2.error; }
            }
            try {
                // Back-patch all pipes declared in the module.
                for (var _h = tslib_1.__values(module.declaredPipes), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var pipeType = _j.value;
                    var pipeMetadata = resolver.getPipeMetadata(pipeType.reference);
                    if (pipeMetadata) {
                        r3_pipe_compiler_1.compilePipe(localCtx, pipeMetadata, reflector, 1 /* BackPatch */);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_j && !_j.done && (_k = _h.return)) _k.call(_h);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (errors.length) {
                throw new Error(errors.map(function (e) { return e.toString(); }).join('\n'));
            }
        }
        outputCtx.statements.push(new o.DeclareFunctionStmt(name, [], tslib_1.__spread(imports, statements), o.INFERRED_TYPE, [o.StmtModifier.Exported]));
        var e_1, _c, e_2, _g, e_3, _k;
    }
    exports.compileModuleBackPatch = compileModuleBackPatch;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicjNfYmFja19wYXRjaF9jb21waWxlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyL3NyYy9yZW5kZXIzL3IzX2JhY2tfcGF0Y2hfY29tcGlsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7O0lBSUgsMkRBQThHO0lBRTlHLDJEQUEwQztJQUMxQyx1RkFBZ0U7SUFJaEUsbUZBQStDO0lBQy9DLG1FQUE4RDtJQUM5RCxtRkFBc0U7SUFPdEU7O09BRUc7SUFDSCxnQ0FDSSxTQUF3QixFQUFFLElBQVksRUFBRSxNQUErQixFQUFFLElBQWdCLEVBQ3pGLG9CQUFtRSxFQUNuRSxhQUtDLEVBQ0QsU0FBMEIsRUFBRSxRQUFpQztRQUMvRCxJQUFNLE9BQU8sR0FBa0IsRUFBRSxDQUFDO1FBQ2xDLElBQUksVUFBVSxHQUFrQixFQUFFLENBQUM7O1lBRW5DLCtCQUErQjtZQUMvQixHQUFHLENBQUMsQ0FBeUIsSUFBQSxLQUFBLGlCQUFBLE1BQU0sQ0FBQyxlQUFlLENBQUEsZ0JBQUE7Z0JBQTlDLElBQU0sY0FBYyxXQUFBO2dCQUN2QixJQUFNLHVCQUF1QixHQUFHLG9CQUFvQixDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFFMUUsa0NBQWtDO2dCQUNsQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxpQ0FBc0IsQ0FBQyxDQUFDLENBQUM7Z0JBRXhELCtDQUErQztnQkFDL0MsT0FBTyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQzthQUMzRDs7Ozs7Ozs7O1FBRUQsNEVBQTRFO1FBQzVFLDJFQUEyRTtRQUMzRSwwREFBMEQ7UUFDMUQsSUFBTSxRQUFRLEdBQWtCO1lBQzlCLFVBQVUsWUFBQTtZQUNWLFlBQVksRUFBRSxTQUFTLENBQUMsWUFBWTtZQUNwQyxXQUFXLEVBQUUsU0FBUyxDQUFDLFdBQVc7WUFDbEMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxVQUFVO1NBQ2pDLENBQUM7UUFFRiw0REFBNEQ7UUFDNUQsRUFBRSxDQUFDLENBQUMsSUFBSSxzQkFBeUIsQ0FBQyxDQUFDLENBQUM7WUFDbEMsNEZBQTRGO1lBQzVGLDRFQUE0RTtZQUU1RSxJQUFNLGdCQUFnQixHQUFHLElBQUksaUJBQU0sQ0FBQyxJQUFJLGdCQUFLLEVBQUUsQ0FBQyxDQUFDO1lBQ2pELElBQU0scUJBQXFCLEdBQUcsSUFBSSxtQ0FBd0IsRUFBRSxDQUFDO1lBQzdELElBQU0sTUFBTSxHQUFpQixFQUFFLENBQUM7WUFDaEMsSUFBTSxpQkFBaUIsR0FBRyxJQUFJLDhCQUFhLENBQ3ZDLGdCQUFnQixFQUFFLHVDQUE0QixFQUFFLHFCQUFxQixFQUFFLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQzs7Z0JBRXZGLG1EQUFtRDtnQkFDbkQsR0FBRyxDQUFDLENBQTRCLElBQUEsS0FBQSxpQkFBQSxNQUFNLENBQUMsa0JBQWtCLENBQUEsZ0JBQUE7b0JBQXBELElBQU0saUJBQWlCLFdBQUE7b0JBQzFCLElBQU0seUJBQXlCLEdBQUcsUUFBUSxDQUFDLG9CQUFvQixDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO29CQUM3RixFQUFFLENBQUMsQ0FBQyx5QkFBeUIsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO3dCQUNwQyxJQUFBLHlGQUNrRixFQURqRiw0QkFBd0IsRUFBRSxzQkFBa0IsQ0FDc0M7d0JBQ3pGLG1DQUFnQixDQUNaLFFBQVEsRUFBRSx5QkFBeUIsRUFBRSxXQUFXLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFDM0UsaUJBQWlCLG9CQUF1QixDQUFDO29CQUMvQyxDQUFDO29CQUFDLElBQUksQ0FBQyxDQUFDO3dCQUNOLG1DQUFnQixDQUNaLFFBQVEsRUFBRSx5QkFBeUIsRUFBRSxTQUFTLEVBQUUsaUJBQWlCLG9CQUM1QyxDQUFDO29CQUM1QixDQUFDO2lCQUNGOzs7Ozs7Ozs7O2dCQUVELCtDQUErQztnQkFDL0MsR0FBRyxDQUFDLENBQW1CLElBQUEsS0FBQSxpQkFBQSxNQUFNLENBQUMsYUFBYSxDQUFBLGdCQUFBO29CQUF0QyxJQUFNLFFBQVEsV0FBQTtvQkFDakIsSUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQ2xFLEVBQUUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7d0JBQ2pCLDhCQUFXLENBQUMsUUFBUSxFQUFFLFlBQVksRUFBRSxTQUFTLG9CQUF1QixDQUFDO29CQUN2RSxDQUFDO2lCQUNGOzs7Ozs7Ozs7WUFFRCxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFaLENBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQzVELENBQUM7UUFDSCxDQUFDO1FBRUQsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsbUJBQW1CLENBQy9DLElBQUksRUFBRSxFQUFFLG1CQUFNLE9BQU8sRUFBSyxVQUFVLEdBQUcsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDOztJQUMxRixDQUFDO0lBNUVELHdEQTRFQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtTdGF0aWNSZWZsZWN0b3J9IGZyb20gJy4uL2FvdC9zdGF0aWNfcmVmbGVjdG9yJztcbmltcG9ydCB7Q29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLCBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhLCBDb21waWxlTmdNb2R1bGVNZXRhZGF0YSwgQ29tcGlsZVBpcGVTdW1tYXJ5LCBDb21waWxlVHlwZU1ldGFkYXRhfSBmcm9tICcuLi9jb21waWxlX21ldGFkYXRhJztcbmltcG9ydCB7REVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRywgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBMZXhlciwgUGFyc2VFcnJvciwgUGFyc2VyfSBmcm9tICcuLi9jb21waWxlcic7XG5pbXBvcnQge0NvbXBpbGVNZXRhZGF0YVJlc29sdmVyfSBmcm9tICcuLi9tZXRhZGF0YV9yZXNvbHZlcic7XG5pbXBvcnQgKiBhcyBvIGZyb20gJy4uL291dHB1dC9vdXRwdXRfYXN0JztcbmltcG9ydCB7QmluZGluZ1BhcnNlcn0gZnJvbSAnLi4vdGVtcGxhdGVfcGFyc2VyL2JpbmRpbmdfcGFyc2VyJztcbmltcG9ydCB7VGVtcGxhdGVBc3R9IGZyb20gJy4uL3RlbXBsYXRlX3BhcnNlci90ZW1wbGF0ZV9hc3QnO1xuaW1wb3J0IHtPdXRwdXRDb250ZXh0fSBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IHtjb21waWxlUGlwZX0gZnJvbSAnLi9yM19waXBlX2NvbXBpbGVyJztcbmltcG9ydCB7QlVJTERfT1BUSU1JWkVSX1JFTU9WRSwgT3V0cHV0TW9kZX0gZnJvbSAnLi9yM190eXBlcyc7XG5pbXBvcnQge2NvbXBpbGVDb21wb25lbnQsIGNvbXBpbGVEaXJlY3RpdmV9IGZyb20gJy4vcjNfdmlld19jb21waWxlcic7XG5cbmV4cG9ydCBjb25zdCBlbnVtIE1vZHVsZUtpbmQge1xuICBSZW5kZXJlcjIsXG4gIFJlbmRlcmVyMyxcbn1cblxuLyoqXG4gKiBQcm9kdWNlIHRoZSBiYWNrLXBhdGNoaW5nIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbW9kdWxlIHRvIHRoZSBvdXRwdXQgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVNb2R1bGVCYWNrUGF0Y2goXG4gICAgb3V0cHV0Q3R4OiBPdXRwdXRDb250ZXh0LCBuYW1lOiBzdHJpbmcsIG1vZHVsZTogQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEsIGtpbmQ6IE1vZHVsZUtpbmQsXG4gICAgYmFja1BhdGNoUmVmZXJlbmNlT2Y6IChtb2R1bGU6IENvbXBpbGVUeXBlTWV0YWRhdGEpID0+IG8uRXhwcmVzc2lvbixcbiAgICBwYXJzZVRlbXBsYXRlOiAoXG4gICAgICAgIGNvbXBNZXRhOiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEsIG5nTW9kdWxlOiBDb21waWxlTmdNb2R1bGVNZXRhZGF0YSxcbiAgICAgICAgZGlyZWN0aXZlSWRlbnRpZmllcnM6IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGFbXSkgPT4ge1xuICAgICAgdGVtcGxhdGU6IFRlbXBsYXRlQXN0W10sXG4gICAgICBwaXBlczogQ29tcGlsZVBpcGVTdW1tYXJ5W11cbiAgICB9LFxuICAgIHJlZmxlY3RvcjogU3RhdGljUmVmbGVjdG9yLCByZXNvbHZlcjogQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIpIHtcbiAgY29uc3QgaW1wb3J0czogby5TdGF0ZW1lbnRbXSA9IFtdO1xuICBsZXQgc3RhdGVtZW50czogby5TdGF0ZW1lbnRbXSA9IFtdO1xuXG4gIC8vIENhbGwgZGVwZW5kZW50IGJhY2sgcGF0Y2hpbmdcbiAgZm9yIChjb25zdCBpbXBvcnRlZE1vZHVsZSBvZiBtb2R1bGUuaW1wb3J0ZWRNb2R1bGVzKSB7XG4gICAgY29uc3QgaW1wb3J0QmFja1BhdGNoRnVuY3Rpb24gPSBiYWNrUGF0Y2hSZWZlcmVuY2VPZihpbXBvcnRlZE1vZHVsZS50eXBlKTtcblxuICAgIC8vIGUuZy4gLy8gQEJVSUxEX09QVElNSVpFUl9SRU1PVkVcbiAgICBpbXBvcnRzLnB1c2gobmV3IG8uQ29tbWVudFN0bXQoQlVJTERfT1BUSU1JWkVSX1JFTU9WRSkpO1xuXG4gICAgLy8gZS5nLiBuZ0JhY2tQYXRjaF9zb21lX290aGVyX21vZHVsZV9Nb2R1bGUoKTtcbiAgICBpbXBvcnRzLnB1c2goaW1wb3J0QmFja1BhdGNoRnVuY3Rpb24uY2FsbEZuKFtdKS50b1N0bXQoKSk7XG4gIH1cblxuICAvLyBUaGUgbG9jYWwgb3V0cHV0IGNvbnRleHQgYWxsb3dzIGNvbGxlY3RpbmcgdGhlIGJhY2stcGF0Y2ggc3RhdGVtZW50cyB0aGF0XG4gIC8vIGFyZSBnZW5lcmF0ZWQgYnkgdGhlIHZhcmlvdXMgY29tcGlsZXJzIHdoaWNoIGFsbG93cyBwdXR0aW5nIHBsYWNpbmcgdGhlbVxuICAvLyBpbnRvIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBhdCBnbG9iYWwgc2NvcGUuXG4gIGNvbnN0IGxvY2FsQ3R4OiBPdXRwdXRDb250ZXh0ID0ge1xuICAgIHN0YXRlbWVudHMsXG4gICAgY29uc3RhbnRQb29sOiBvdXRwdXRDdHguY29uc3RhbnRQb29sLFxuICAgIGdlbkZpbGVQYXRoOiBvdXRwdXRDdHguZ2VuRmlsZVBhdGgsXG4gICAgaW1wb3J0RXhwcjogb3V0cHV0Q3R4LmltcG9ydEV4cHJcbiAgfTtcblxuICAvLyBlLmcuIGV4cG9ydCBmdW5jdGlvbiBuZ0JhY2tQYXRjaF9zb21lX21vZHVsZV9MaWIxTW9kdWxlKClcbiAgaWYgKGtpbmQgPT09IE1vZHVsZUtpbmQuUmVuZGVyZXIyKSB7XG4gICAgLy8gRm9yIGFsbCBSZW5kZXJlcjIgbW9kdWxlcyBnZW5lcmF0ZSBiYWNrLXBhdGNoaW5nIGNvZGUgZm9yIGFsbCB0aGUgY29tcG9uZW50cywgZGlyZWN0aXZlcyxcbiAgICAvLyBwaXBlcywgYW5kIGluamVjdGFibGVzIGFzIHdlbGwgYXMgdGhlIGluamVjdG9yIGRlZiBmb3IgdGhlIG1vZHVsZSBpdHNlbGYuXG5cbiAgICBjb25zdCBleHByZXNzaW9uUGFyc2VyID0gbmV3IFBhcnNlcihuZXcgTGV4ZXIoKSk7XG4gICAgY29uc3QgZWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gbmV3IERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpO1xuICAgIGNvbnN0IGVycm9yczogUGFyc2VFcnJvcltdID0gW107XG4gICAgY29uc3QgaG9zdEJpbmRpbmdQYXJzZXIgPSBuZXcgQmluZGluZ1BhcnNlcihcbiAgICAgICAgZXhwcmVzc2lvblBhcnNlciwgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRywgZWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBbXSwgZXJyb3JzKTtcblxuICAgIC8vIEJhY2stcGF0Y2ggYWxsIGRlY2xhcmVkIGRpcmVjdGl2ZSBhbmQgY29tcG9uZW50c1xuICAgIGZvciAoY29uc3QgZGVjbGFyZWREaXJlY3RpdmUgb2YgbW9kdWxlLmRlY2xhcmVkRGlyZWN0aXZlcykge1xuICAgICAgY29uc3QgZGVjbGFyZWREaXJlY3RpdmVNZXRhZGF0YSA9IHJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRlY2xhcmVkRGlyZWN0aXZlLnJlZmVyZW5jZSk7XG4gICAgICBpZiAoZGVjbGFyZWREaXJlY3RpdmVNZXRhZGF0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICBjb25zdCB7dGVtcGxhdGU6IHBhcnNlZFRlbXBsYXRlLCBwaXBlczogcGFyc2VkUGlwZXN9ID1cbiAgICAgICAgICAgIHBhcnNlVGVtcGxhdGUoZGVjbGFyZWREaXJlY3RpdmVNZXRhZGF0YSwgbW9kdWxlLCBtb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzKTtcbiAgICAgICAgY29tcGlsZUNvbXBvbmVudChcbiAgICAgICAgICAgIGxvY2FsQ3R4LCBkZWNsYXJlZERpcmVjdGl2ZU1ldGFkYXRhLCBwYXJzZWRQaXBlcywgcGFyc2VkVGVtcGxhdGUsIHJlZmxlY3RvcixcbiAgICAgICAgICAgIGhvc3RCaW5kaW5nUGFyc2VyLCBPdXRwdXRNb2RlLkJhY2tQYXRjaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21waWxlRGlyZWN0aXZlKFxuICAgICAgICAgICAgbG9jYWxDdHgsIGRlY2xhcmVkRGlyZWN0aXZlTWV0YWRhdGEsIHJlZmxlY3RvciwgaG9zdEJpbmRpbmdQYXJzZXIsXG4gICAgICAgICAgICBPdXRwdXRNb2RlLkJhY2tQYXRjaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQmFjay1wYXRjaCBhbGwgcGlwZXMgZGVjbGFyZWQgaW4gdGhlIG1vZHVsZS5cbiAgICBmb3IgKGNvbnN0IHBpcGVUeXBlIG9mIG1vZHVsZS5kZWNsYXJlZFBpcGVzKSB7XG4gICAgICBjb25zdCBwaXBlTWV0YWRhdGEgPSByZXNvbHZlci5nZXRQaXBlTWV0YWRhdGEocGlwZVR5cGUucmVmZXJlbmNlKTtcbiAgICAgIGlmIChwaXBlTWV0YWRhdGEpIHtcbiAgICAgICAgY29tcGlsZVBpcGUobG9jYWxDdHgsIHBpcGVNZXRhZGF0YSwgcmVmbGVjdG9yLCBPdXRwdXRNb2RlLkJhY2tQYXRjaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMubWFwKGUgPT4gZS50b1N0cmluZygpKS5qb2luKCdcXG4nKSk7XG4gICAgfVxuICB9XG5cbiAgb3V0cHV0Q3R4LnN0YXRlbWVudHMucHVzaChuZXcgby5EZWNsYXJlRnVuY3Rpb25TdG10KFxuICAgICAgbmFtZSwgW10sIFsuLi5pbXBvcnRzLCAuLi5zdGF0ZW1lbnRzXSwgby5JTkZFUlJFRF9UWVBFLCBbby5TdG10TW9kaWZpZXIuRXhwb3J0ZWRdKSk7XG59XG4iXX0=