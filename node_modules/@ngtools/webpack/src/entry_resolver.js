"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const fs = require("fs");
const path_1 = require("path");
const ts = require("typescript");
const refactor_1 = require("./refactor");
function _recursiveSymbolExportLookup(refactor, symbolName, host, program) {
    // Check this file.
    const hasSymbol = refactor.findAstNodes(null, ts.SyntaxKind.ClassDeclaration)
        .some((cd) => {
        return cd.name != undefined && cd.name.text == symbolName;
    });
    if (hasSymbol) {
        return refactor.fileName;
    }
    // We found the bootstrap variable, now we just need to get where it's imported.
    const exports = refactor.findAstNodes(null, ts.SyntaxKind.ExportDeclaration)
        .map(node => node);
    for (const decl of exports) {
        if (!decl.moduleSpecifier || decl.moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {
            continue;
        }
        const modulePath = decl.moduleSpecifier.text;
        const resolvedModule = ts.resolveModuleName(modulePath, refactor.fileName, program.getCompilerOptions(), host);
        if (!resolvedModule.resolvedModule || !resolvedModule.resolvedModule.resolvedFileName) {
            return null;
        }
        const module = resolvedModule.resolvedModule.resolvedFileName;
        if (!decl.exportClause) {
            const moduleRefactor = new refactor_1.TypeScriptFileRefactor(module, host, program);
            const maybeModule = _recursiveSymbolExportLookup(moduleRefactor, symbolName, host, program);
            if (maybeModule) {
                return maybeModule;
            }
            continue;
        }
        const binding = decl.exportClause;
        for (const specifier of binding.elements) {
            if (specifier.name.text == symbolName) {
                // If it's a directory, load its index and recursively lookup.
                if (fs.statSync(module).isDirectory()) {
                    const indexModule = path_1.join(module, 'index.ts');
                    if (fs.existsSync(indexModule)) {
                        const indexRefactor = new refactor_1.TypeScriptFileRefactor(indexModule, host, program);
                        const maybeModule = _recursiveSymbolExportLookup(indexRefactor, symbolName, host, program);
                        if (maybeModule) {
                            return maybeModule;
                        }
                    }
                }
                // Create the source and verify that the symbol is at least a class.
                const source = new refactor_1.TypeScriptFileRefactor(module, host, program);
                const hasSymbol = source.findAstNodes(null, ts.SyntaxKind.ClassDeclaration)
                    .some((cd) => {
                    return cd.name != undefined && cd.name.text == symbolName;
                });
                if (hasSymbol) {
                    return module;
                }
            }
        }
    }
    return null;
}
function _symbolImportLookup(refactor, symbolName, host, program) {
    // We found the bootstrap variable, now we just need to get where it's imported.
    const imports = refactor.findAstNodes(null, ts.SyntaxKind.ImportDeclaration)
        .map(node => node);
    for (const decl of imports) {
        if (!decl.importClause || !decl.moduleSpecifier) {
            continue;
        }
        if (decl.moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {
            continue;
        }
        const resolvedModule = ts.resolveModuleName(decl.moduleSpecifier.text, refactor.fileName, program.getCompilerOptions(), host);
        if (!resolvedModule.resolvedModule || !resolvedModule.resolvedModule.resolvedFileName) {
            continue;
        }
        const module = resolvedModule.resolvedModule.resolvedFileName;
        if (decl.importClause.namedBindings
            && decl.importClause.namedBindings.kind == ts.SyntaxKind.NamespaceImport) {
            const binding = decl.importClause.namedBindings;
            if (binding.name.text == symbolName) {
                // This is a default export.
                return module;
            }
        }
        else if (decl.importClause.namedBindings
            && decl.importClause.namedBindings.kind == ts.SyntaxKind.NamedImports) {
            const binding = decl.importClause.namedBindings;
            for (const specifier of binding.elements) {
                if (specifier.name.text == symbolName) {
                    // Create the source and recursively lookup the import.
                    const source = new refactor_1.TypeScriptFileRefactor(module, host, program);
                    const maybeModule = _recursiveSymbolExportLookup(source, symbolName, host, program);
                    if (maybeModule) {
                        return maybeModule;
                    }
                }
            }
        }
    }
    return null;
}
function resolveEntryModuleFromMain(mainPath, host, program) {
    const source = new refactor_1.TypeScriptFileRefactor(mainPath, host, program);
    const bootstrap = source.findAstNodes(source.sourceFile, ts.SyntaxKind.CallExpression, true)
        .map(node => node)
        .filter(call => {
        const access = call.expression;
        return access.kind == ts.SyntaxKind.PropertyAccessExpression
            && access.name.kind == ts.SyntaxKind.Identifier
            && (access.name.text == 'bootstrapModule'
                || access.name.text == 'bootstrapModuleFactory');
    })
        .map(node => node.arguments[0])
        .filter(node => node.kind == ts.SyntaxKind.Identifier);
    if (bootstrap.length != 1) {
        return null;
    }
    const bootstrapSymbolName = bootstrap[0].text;
    const module = _symbolImportLookup(source, bootstrapSymbolName, host, program);
    if (module) {
        return `${module.replace(/\.ts$/, '')}#${bootstrapSymbolName}`;
    }
    // shrug... something bad happened and we couldn't find the import statement.
    throw new Error('Tried to find bootstrap code, but could not. Specify either '
        + 'statically analyzable bootstrap code or pass in an entryModule '
        + 'to the plugins options.');
}
exports.resolveEntryModuleFromMain = resolveEntryModuleFromMain;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50cnlfcmVzb2x2ZXIuanMiLCJzb3VyY2VSb290IjoiLi8iLCJzb3VyY2VzIjpbInBhY2thZ2VzL25ndG9vbHMvd2VicGFjay9zcmMvZW50cnlfcmVzb2x2ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7O0dBTUc7QUFDSCx5QkFBeUI7QUFDekIsK0JBQTRCO0FBQzVCLGlDQUFpQztBQUNqQyx5Q0FBb0Q7QUFHcEQsc0NBQXNDLFFBQWdDLEVBQ2hDLFVBQWtCLEVBQ2xCLElBQXFCLEVBQ3JCLE9BQW1CO0lBQ3ZELG1CQUFtQjtJQUNuQixNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDO1NBQzFFLElBQUksQ0FBQyxDQUFDLEVBQXVCLEVBQUUsRUFBRTtRQUNoQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxTQUFTLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksVUFBVSxDQUFDO0lBQzVELENBQUMsQ0FBQyxDQUFDO0lBQ0wsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUNkLE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDO0lBQzNCLENBQUM7SUFFRCxnRkFBZ0Y7SUFDaEYsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQztTQUN6RSxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUE0QixDQUFDLENBQUM7SUFFN0MsR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFJLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztRQUMzQixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxlQUFlLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMs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QUFNLEVBQUUsbUJBQW1CLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQy9FLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDWCxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsSUFBSSxtQkFBbUIsRUFBRSxDQUFDO0lBQ2pFLENBQUM7SUFFRCw2RUFBNkU7SUFDN0UsTUFBTSxJQUFJLEtBQUssQ0FBQyw4REFBOEQ7VUFDMUUsaUVBQWlFO1VBQ2pFLHlCQUF5QixDQUFDLENBQUM7QUFDakMsQ0FBQztBQS9CRCxnRUErQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcbmltcG9ydCB7IFR5cGVTY3JpcHRGaWxlUmVmYWN0b3IgfSBmcm9tICcuL3JlZmFjdG9yJztcblxuXG5mdW5jdGlvbiBfcmVjdXJzaXZlU3ltYm9sRXhwb3J0TG9va3VwKHJlZmFjdG9yOiBUeXBlU2NyaXB0RmlsZVJlZmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xOYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHRzLkNvbXBpbGVySG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbTogdHMuUHJvZ3JhbSk6IHN0cmluZyB8IG51bGwge1xuICAvLyBDaGVjayB0aGlzIGZpbGUuXG4gIGNvbnN0IGhhc1N5bWJvbCA9IHJlZmFjdG9yLmZpbmRBc3ROb2RlcyhudWxsLCB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb24pXG4gICAgLnNvbWUoKGNkOiB0cy5DbGFzc0RlY2xhcmF0aW9uKSA9PiB7XG4gICAgICByZXR1cm4gY2QubmFtZSAhPSB1bmRlZmluZWQgJiYgY2QubmFtZS50ZXh0ID09IHN5bWJvbE5hbWU7XG4gICAgfSk7XG4gIGlmIChoYXNTeW1ib2wpIHtcbiAgICByZXR1cm4gcmVmYWN0b3IuZmlsZU5hbWU7XG4gIH1cblxuICAvLyBXZSBmb3VuZCB0aGUgYm9vdHN0cmFwIHZhcmlhYmxlLCBub3cgd2UganVzdCBuZWVkIHRvIGdldCB3aGVyZSBpdCdzIGltcG9ydGVkLlxuICBjb25zdCBleHBvcnRzID0gcmVmYWN0b3IuZmluZEFzdE5vZGVzKG51bGwsIHRzLlN5bnRheEtpbmQuRXhwb3J0RGVjbGFyYXRpb24pXG4gICAgLm1hcChub2RlID0+IG5vZGUgYXMgdHMuRXhwb3J0RGVjbGFyYXRpb24pO1xuXG4gIGZvciAoY29uc3QgZGVjbCBvZiBleHBvcnRzKSB7XG4gICAgaWYgKCFkZWNsLm1vZHVsZVNwZWNpZmllciB8fCBkZWNsLm1vZHVsZVNwZWNpZmllci5raW5kICE9PSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZHVsZVBhdGggPSAoZGVjbC5tb2R1bGVTcGVjaWZpZXIgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbiAgICBjb25zdCByZXNvbHZlZE1vZHVsZSA9IHRzLnJlc29sdmVNb2R1bGVOYW1lKFxuICAgICAgbW9kdWxlUGF0aCwgcmVmYWN0b3IuZmlsZU5hbWUsIHByb2dyYW0uZ2V0Q29tcGlsZXJPcHRpb25zKCksIGhvc3QpO1xuICAgIGlmICghcmVzb2x2ZWRNb2R1bGUucmVzb2x2ZWRNb2R1bGUgfHwgIXJlc29sdmVkTW9kdWxlLnJlc29sdmVkTW9kdWxlLnJlc29sdmVkRmlsZU5hbWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZHVsZSA9IHJlc29sdmVkTW9kdWxlLnJlc29sdmVkTW9kdWxlLnJlc29sdmVkRmlsZU5hbWU7XG4gICAgaWYgKCFkZWNsLmV4cG9ydENsYXVzZSkge1xuICAgICAgY29uc3QgbW9kdWxlUmVmYWN0b3IgPSBuZXcgVHlwZVNjcmlwdEZpbGVSZWZhY3Rvcihtb2R1bGUsIGhvc3QsIHByb2dyYW0pO1xuICAgICAgY29uc3QgbWF5YmVNb2R1bGUgPSBfcmVjdXJzaXZlU3ltYm9sRXhwb3J0TG9va3VwKG1vZHVsZVJlZmFjdG9yLCBzeW1ib2xOYW1lLCBob3N0LCBwcm9ncmFtKTtcbiAgICAgIGlmIChtYXliZU1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbWF5YmVNb2R1bGU7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBiaW5kaW5nID0gZGVjbC5leHBvcnRDbGF1c2UgYXMgdHMuTmFtZWRFeHBvcnRzO1xuICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIGJpbmRpbmcuZWxlbWVudHMpIHtcbiAgICAgIGlmIChzcGVjaWZpZXIubmFtZS50ZXh0ID09IHN5bWJvbE5hbWUpIHtcbiAgICAgICAgLy8gSWYgaXQncyBhIGRpcmVjdG9yeSwgbG9hZCBpdHMgaW5kZXggYW5kIHJlY3Vyc2l2ZWx5IGxvb2t1cC5cbiAgICAgICAgaWYgKGZzLnN0YXRTeW5jKG1vZHVsZSkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgIGNvbnN0IGluZGV4TW9kdWxlID0gam9pbihtb2R1bGUsICdpbmRleC50cycpO1xuICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGluZGV4TW9kdWxlKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhSZWZhY3RvciA9IG5ldyBUeXBlU2NyaXB0RmlsZVJlZmFjdG9yKGluZGV4TW9kdWxlLCBob3N0LCBwcm9ncmFtKTtcbiAgICAgICAgICAgIGNvbnN0IG1heWJlTW9kdWxlID0gX3JlY3Vyc2l2ZVN5bWJvbEV4cG9ydExvb2t1cChcbiAgICAgICAgICAgICAgaW5kZXhSZWZhY3Rvciwgc3ltYm9sTmFtZSwgaG9zdCwgcHJvZ3JhbSk7XG4gICAgICAgICAgICBpZiAobWF5YmVNb2R1bGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1heWJlTW9kdWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgc291cmNlIGFuZCB2ZXJpZnkgdGhhdCB0aGUgc3ltYm9sIGlzIGF0IGxlYXN0IGEgY2xhc3MuXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBUeXBlU2NyaXB0RmlsZVJlZmFjdG9yKG1vZHVsZSwgaG9zdCwgcHJvZ3JhbSk7XG4gICAgICAgIGNvbnN0IGhhc1N5bWJvbCA9IHNvdXJjZS5maW5kQXN0Tm9kZXMobnVsbCwgdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uKVxuICAgICAgICAgIC5zb21lKChjZDogdHMuQ2xhc3NEZWNsYXJhdGlvbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNkLm5hbWUgIT0gdW5kZWZpbmVkICYmIGNkLm5hbWUudGV4dCA9PSBzeW1ib2xOYW1lO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChoYXNTeW1ib2wpIHtcbiAgICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIF9zeW1ib2xJbXBvcnRMb29rdXAocmVmYWN0b3I6IFR5cGVTY3JpcHRGaWxlUmVmYWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbE5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogdHMuQ29tcGlsZXJIb3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmFtOiB0cy5Qcm9ncmFtKTogc3RyaW5nIHwgbnVsbCB7XG4gIC8vIFdlIGZvdW5kIHRoZSBib290c3RyYXAgdmFyaWFibGUsIG5vdyB3ZSBqdXN0IG5lZWQgdG8gZ2V0IHdoZXJlIGl0J3MgaW1wb3J0ZWQuXG4gIGNvbnN0IGltcG9ydHMgPSByZWZhY3Rvci5maW5kQXN0Tm9kZXMobnVsbCwgdHMuU3ludGF4S2luZC5JbXBvcnREZWNsYXJhdGlvbilcbiAgICAubWFwKG5vZGUgPT4gbm9kZSBhcyB0cy5JbXBvcnREZWNsYXJhdGlvbik7XG5cbiAgZm9yIChjb25zdCBkZWNsIG9mIGltcG9ydHMpIHtcbiAgICBpZiAoIWRlY2wuaW1wb3J0Q2xhdXNlIHx8ICFkZWNsLm1vZHVsZVNwZWNpZmllcikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChkZWNsLm1vZHVsZVNwZWNpZmllci5raW5kICE9PSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc29sdmVkTW9kdWxlID0gdHMucmVzb2x2ZU1vZHVsZU5hbWUoXG4gICAgICAoZGVjbC5tb2R1bGVTcGVjaWZpZXIgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dCxcbiAgICAgIHJlZmFjdG9yLmZpbGVOYW1lLCBwcm9ncmFtLmdldENvbXBpbGVyT3B0aW9ucygpLCBob3N0KTtcbiAgICBpZiAoIXJlc29sdmVkTW9kdWxlLnJlc29sdmVkTW9kdWxlIHx8ICFyZXNvbHZlZE1vZHVsZS5yZXNvbHZlZE1vZHVsZS5yZXNvbHZlZEZpbGVOYW1lKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBtb2R1bGUgPSByZXNvbHZlZE1vZHVsZS5yZXNvbHZlZE1vZHVsZS5yZXNvbHZlZEZpbGVOYW1lO1xuICAgIGlmIChkZWNsLmltcG9ydENsYXVzZS5uYW1lZEJpbmRpbmdzXG4gICAgICAgICYmIGRlY2wuaW1wb3J0Q2xhdXNlLm5hbWVkQmluZGluZ3Mua2luZCA9PSB0cy5TeW50YXhLaW5kLk5hbWVzcGFjZUltcG9ydCkge1xuICAgICAgY29uc3QgYmluZGluZyA9IGRlY2wuaW1wb3J0Q2xhdXNlLm5hbWVkQmluZGluZ3MgYXMgdHMuTmFtZXNwYWNlSW1wb3J0O1xuICAgICAgaWYgKGJpbmRpbmcubmFtZS50ZXh0ID09IHN5bWJvbE5hbWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGRlZmF1bHQgZXhwb3J0LlxuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGVjbC5pbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5nc1xuICAgICAgICAgICAgICAgJiYgZGVjbC5pbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncy5raW5kID09IHRzLlN5bnRheEtpbmQuTmFtZWRJbXBvcnRzKSB7XG4gICAgICBjb25zdCBiaW5kaW5nID0gZGVjbC5pbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncyBhcyB0cy5OYW1lZEltcG9ydHM7XG4gICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBiaW5kaW5nLmVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChzcGVjaWZpZXIubmFtZS50ZXh0ID09IHN5bWJvbE5hbWUpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgdGhlIHNvdXJjZSBhbmQgcmVjdXJzaXZlbHkgbG9va3VwIHRoZSBpbXBvcnQuXG4gICAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IFR5cGVTY3JpcHRGaWxlUmVmYWN0b3IobW9kdWxlLCBob3N0LCBwcm9ncmFtKTtcbiAgICAgICAgICBjb25zdCBtYXliZU1vZHVsZSA9IF9yZWN1cnNpdmVTeW1ib2xFeHBvcnRMb29rdXAoc291cmNlLCBzeW1ib2xOYW1lLCBob3N0LCBwcm9ncmFtKTtcbiAgICAgICAgICBpZiAobWF5YmVNb2R1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXliZU1vZHVsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUVudHJ5TW9kdWxlRnJvbU1haW4obWFpblBhdGg6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB0cy5Db21waWxlckhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbTogdHMuUHJvZ3JhbSk6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCBzb3VyY2UgPSBuZXcgVHlwZVNjcmlwdEZpbGVSZWZhY3RvcihtYWluUGF0aCwgaG9zdCwgcHJvZ3JhbSk7XG5cbiAgY29uc3QgYm9vdHN0cmFwID0gc291cmNlLmZpbmRBc3ROb2Rlcyhzb3VyY2Uuc291cmNlRmlsZSwgdHMuU3ludGF4S2luZC5DYWxsRXhwcmVzc2lvbiwgdHJ1ZSlcbiAgICAubWFwKG5vZGUgPT4gbm9kZSBhcyB0cy5DYWxsRXhwcmVzc2lvbilcbiAgICAuZmlsdGVyKGNhbGwgPT4ge1xuICAgICAgY29uc3QgYWNjZXNzID0gY2FsbC5leHByZXNzaW9uIGFzIHRzLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbjtcblxuICAgICAgcmV0dXJuIGFjY2Vzcy5raW5kID09IHRzLlN5bnRheEtpbmQuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uXG4gICAgICAgICAgJiYgYWNjZXNzLm5hbWUua2luZCA9PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXJcbiAgICAgICAgICAmJiAoYWNjZXNzLm5hbWUudGV4dCA9PSAnYm9vdHN0cmFwTW9kdWxlJ1xuICAgICAgICAgICAgICB8fCBhY2Nlc3MubmFtZS50ZXh0ID09ICdib290c3RyYXBNb2R1bGVGYWN0b3J5Jyk7XG4gICAgfSlcbiAgICAubWFwKG5vZGUgPT4gbm9kZS5hcmd1bWVudHNbMF0gYXMgdHMuSWRlbnRpZmllcilcbiAgICAuZmlsdGVyKG5vZGUgPT4gbm9kZS5raW5kID09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcik7XG5cbiAgaWYgKGJvb3RzdHJhcC5sZW5ndGggIT0gMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGJvb3RzdHJhcFN5bWJvbE5hbWUgPSBib290c3RyYXBbMF0udGV4dDtcbiAgY29uc3QgbW9kdWxlID0gX3N5bWJvbEltcG9ydExvb2t1cChzb3VyY2UsIGJvb3RzdHJhcFN5bWJvbE5hbWUsIGhvc3QsIHByb2dyYW0pO1xuICBpZiAobW9kdWxlKSB7XG4gICAgcmV0dXJuIGAke21vZHVsZS5yZXBsYWNlKC9cXC50cyQvLCAnJyl9IyR7Ym9vdHN0cmFwU3ltYm9sTmFtZX1gO1xuICB9XG5cbiAgLy8gc2hydWcuLi4gc29tZXRoaW5nIGJhZCBoYXBwZW5lZCBhbmQgd2UgY291bGRuJ3QgZmluZCB0aGUgaW1wb3J0IHN0YXRlbWVudC5cbiAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBmaW5kIGJvb3RzdHJhcCBjb2RlLCBidXQgY291bGQgbm90LiBTcGVjaWZ5IGVpdGhlciAnXG4gICAgKyAnc3RhdGljYWxseSBhbmFseXphYmxlIGJvb3RzdHJhcCBjb2RlIG9yIHBhc3MgaW4gYW4gZW50cnlNb2R1bGUgJ1xuICAgICsgJ3RvIHRoZSBwbHVnaW5zIG9wdGlvbnMuJyk7XG59XG4iXX0=